import streamlit as st
import os
import base64

# Define the path to your malicious files directory
#malicious_files_dir = "/home/olimbi/bachelor-thesis/rep"
malicious_files_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), "../bachelor-thesis/rep"))

# Information about each file (file name as key)
files_info = {
    "Friday-WorkingHours-Afternoon-DDos_aligned.csv": "The Friday-WorkingHours-Afternoon-DDos_aligned.csv file is part of the CICDDoS2019 dataset, which captures real-world-like network traffic, including various DDoS attacks. This file contains data from attacks such as PortMap, NetBIOS, LDAP, MSSQL, UDP, UDP-Lag, SYN, NTP, DNS, SNMP, SSDP, WebDDoS, and TFTP. The attacks were carried out over two days, with each attack recorded alongside normal network activity to help test and evaluate network intrusion detection systems.",
    "Bad-DDOS.csv": "The Bad-DDOS.csv file is part of the training dataset, featuring around 130,000 packets that include both benign and mostly DDoS traffic (unlabeled) for testing.",
    "filtered_DarkWave.csv": "filtered_DarkWave.csv is a CSV file converted from the DarkWave.pcap, containing data from 700,000 network packets captured during a Mirai botnet infection, specifically prepared to test the Random Forest machine learning model for anomaly detection.",
    "DarkWave.pcap": "DarkWave contains approximately 700,000 packets captured over 118 minutes during a network infection by the Mirai botnet malware.",
    "DarkWave.png": "This image shows the anomaly scores generated by Kitsune during the processing of the DarkWave.pcap file, which contains 700,000 packets. The RMSE values are displayed on a logarithmic scale, with higher scores and red colors indicating more significant anomalies.",
    "filtered_bigFlows.csv": "filtered_bigFlows.csv is a CSV file created from the bigFlows.pcap, containing nearly 800,000 packets recorded during an OS Scanning. It’s intended for testing the Random Forest model in detecting anomalies.",
    "bigFlows.pcap": "bigFlows contains nearly 800,000 packets captured over 5 minutes during a network infection by the OS Scanning.",
    "bigFlows.png": "This graph displays the anomaly scores generated by Kitsune during the processing of the bigFlows.pcap file, which contains 800,000 packets. The RMSE values are shown on a logarithmic scale, with a high number of scores and red colors indicating significant anomalies caused by OS Scanning during a 5-minute period.",
    "filtered_home-400k.csv": "filtered_home-400k.csv is a CSV file created from home-400k.pcap, containing data from 400,000 packets of normal home network activity, making it useful for identifying and differentiating typical network behavior.",
    "home-400k.pcap": "home-400k contains 400,000 packets captured over 7 minutes during normal home network activity.",
    "home-400k.png": "This image shows the anomaly scores generated by Kitsune during the processing of the home-400k.pcap file, which contains 400,000 packets of normal home network activity. The RMSE values are displayed on a logarithmic scale, with only one red dot indicating a minor anomaly that is not significant.",
}

# Function to get the correct file path
def get_file_path(file):
    return os.path.join(malicious_files_dir, file)

# Streamlit app
st.title("Malicious File Repository")
st.info(
    """
    This page showcases my results in a repository containing malicious data samples in .pcap, .pcapng, .csv, and .png formats. 
    These files are designed to help test and simulate using the Kitsune autoencoder-based framework and the Random Forest classifier.
    """
)

# Create tabs for different categories
tab1, tab2, tab3 = st.tabs(["PCAP Files", "CSV Files", "Images"])

# PCAP Files tab
with tab1:
    st.header("PCAP Files")
    pcap_files = {k: v for k, v in files_info.items() if k.endswith('.pcap') or k.endswith('.pcapng')}
    for file, description in pcap_files.items():
        file_path = get_file_path(file)
        if os.path.exists(file_path):
            st.markdown("### " + file)
            st.write(description)
            with open(file_path, "rb") as f:
                st.download_button(
                    label=f"⬇️ Download {file}",
                    data=f,
                    file_name=file,
                    mime="application/octet-stream"
                )
            st.markdown("---")

# CSV Files tab
with tab2:
    st.header("CSV Files")
    csv_files = {k: v for k, v in files_info.items() if k.endswith('.csv')}
    for file, description in csv_files.items():
        file_path = get_file_path(file)
        if os.path.exists(file_path):
            st.markdown("### " + file)
            st.write(description)
            with open(file_path, "rb") as f:
                st.download_button(
                    label=f"⬇️ Download {file}",
                    data=f,
                    file_name=file,
                    mime="application/octet-stream"
                )
            st.markdown("---")

# Images tab
with tab3:
    st.header("Images")
    image_files = {k: v for k, v in files_info.items() if k.endswith('.png')}
    for file, description in image_files.items():
        file_path = get_file_path(file)
        if os.path.exists(file_path):
            st.markdown("### " + file)
            st.write(description)
            with open(file_path, "rb") as img_file:
                encoded_image = base64.b64encode(img_file.read()).decode()

            st.markdown(
                f"""
                <div style="border: 1px #ccc; padding: 10px; margin-bottom: 20px;">
                    <img src="data:image/png;base64,{encoded_image}" style="width:100%; border-radius: 10px;" />
                    <div style="text-align: center; margin-top: 10px;">{file}</div>
                </div>
                """,
                unsafe_allow_html=True
            )

            with open(file_path, "rb") as f:
                st.download_button(
                    label=f"⬇️ Download {file}",
                    data=f,
                    file_name=file,
                    mime="image/png"
                )
            st.markdown("---")
